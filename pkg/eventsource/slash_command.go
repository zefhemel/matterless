package eventsource

import (
	"fmt"
	"github.com/mattermost/mattermost-server/model"
	log "github.com/sirupsen/logrus"
	"github.com/zefhemel/matterless/pkg/definition"
	"net/http"
	"os"
	"strings"
)

type SlashCommandSource struct {
	externalURL string
	commandID   string
	adminClient *model.Client4
	sourceName  string
	def         *definition.SlashCommandDef
	token       string
}

func (s *SlashCommandSource) Start() error {
	team, resp := s.adminClient.GetTeamByName(s.def.TeamName, "")
	if resp.Error != nil {
		return resp.Error
	}
	// First find if an existing already exists, if so we'll patch it
	customCommands, resp := s.adminClient.ListCommands(team.Id, true)
	foundExisting := false
	for _, cmd := range customCommands {
		if cmd.Trigger == s.def.Trigger {
			log.Debug("Found existing command, patching")
			cmd.Method = "P"
			cmd.DisplayName = s.def.Trigger
			cmd.Description = "Auto generated by Matterless"
			cmd.URL = s.externalURL
			updatedCmd, resp := s.adminClient.UpdateCommand(cmd)
			if resp.Error != nil {
				return resp.Error
			}
			s.token = updatedCmd.Token
			s.commandID = cmd.Id
			log.Info("Done")
			foundExisting = true
		}
	}
	// Then, create it anew
	if !foundExisting {
		log.Debug("Creating new command")
		cmd, resp := s.adminClient.CreateCommand(&model.Command{
			TeamId:       team.Id,
			Trigger:      s.def.Trigger,
			Method:       "P",
			AutoComplete: false,
			DisplayName:  s.def.Trigger,
			Description:  "Auto generated by Matterless",
			URL:          s.externalURL,
		})
		if resp.Error != nil {
			return resp.Error
		}
		s.commandID = cmd.Id
		s.token = cmd.Token
	}
	return nil
}

func (s *SlashCommandSource) Stop() {
	if s.commandID != "" {
		_, resp := s.adminClient.DeleteCommand(s.commandID)
		if resp.Error != nil {
			log.Error("Could not remove command", resp.Error)
		}
	}
}

func (s *SlashCommandSource) ExtendDefinitions(defs *definition.Definitions) {
	// Extend the API Gateway and add a /callback endpoint
	defs.APIGateways[s.sourceName] = &definition.APIGatewayDef{
		Endpoints: []definition.EndpointDef{{
			Path:     "/callback",
			Methods:  []string{"POST"},
			Function: s.def.Function,
			PreProcess: func(event interface{}) interface{} {
				if apiGatewayEvent, ok := event.(*definition.APIGatewayRequestEvent); ok {
					// Use the form values to the top level of the event, ignore everything else
					return apiGatewayEvent.FormValues
				} else {
					return event
				}
			},
			PostProcess: func(result interface{}) interface{} {
				return &definition.APIGatewayResponse{
					Status: http.StatusOK,
					Body:   result,
				}
			},
		}},
	}

	defs.Environment[fmt.Sprintf("%s_URL", strings.ToUpper(s.sourceName))] = s.adminClient.Url
	defs.Environment[fmt.Sprintf("%s_TOKEN", strings.ToUpper(s.sourceName))] = s.token

}

func NewSlashCommandSource(adminClient *model.Client4, appName, sourceName string, def *definition.SlashCommandDef, invokeFunc FunctionInvokeFunc) *SlashCommandSource {
	scs := &SlashCommandSource{
		adminClient: adminClient,
		def:         def,
		sourceName:  sourceName,
	}

	// TODO: Let's not pull this from the environment variables here directly
	scs.externalURL = fmt.Sprintf("%s/%s/%s/callback", os.Getenv("api_url"), appName, sourceName)

	return scs
}

var _ EventSource = &SlashCommandSource{}
